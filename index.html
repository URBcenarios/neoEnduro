<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neo Enduro: Remastered</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; touch-action: none; user-select: none; -webkit-user-select: none; }

        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; flex-direction: column; }

        canvas { display: block; width: 100%; flex: 1; background: #000; image-rendering: pixelated; }

        /* UI */
        .hud-text { position: absolute; color: #fff; font-weight: bold; text-shadow: 2px 2px #000; z-index: 10; pointer-events: none; }
        #top-hud { top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 18px; }
        #timer { color: #ffcc00; font-size: 24px; }
        #center-hud { position: absolute; top: 10%; width: 100%; text-align: center; color: #fff; font-size: 14px; text-shadow: 1px 1px #000; z-index: 9;}

        #message-area { position: absolute; top: 30%; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
        .msg { font-size: 32px; font-weight: 900; text-shadow: 0 0 10px #000; display: none; text-transform: uppercase; font-style: italic;}
        #msg-checkpoint { color: #00ff00; }
        #msg-level { color: #ff00ff; font-size: 20px; margin-top: 5px; }

        /* Controls */
        #controls { height: 15vh; min-height: 100px; background: #1a1a1a; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 5px 10px; border-top: 2px solid #444; flex-shrink: 0; }
        .d-pad, .action-btn { display: flex; justify-content: center; align-items: center; gap: 15px; }
        button { background: linear-gradient(to bottom, #333, #000); border: 2px solid #666; border-radius: 50%; color: white; font-size: 24px; width: 65px; height: 65px; box-shadow: 0 4px 0 #000; }
        button:active { transform: translateY(4px); box-shadow: none; background: #444; }
        .btn-rect { border-radius: 10px; width: 100%; height: 65px; font-size: 18px; font-weight: bold; background: linear-gradient(to bottom, #d32f2f, #8e0000); border-color: #ff6659; }

        /* Screens */
        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; text-align: center; cursor: pointer; }
        .hidden { display: none !important; }

        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .blink-text { animation: blink 0.8s infinite; font-size: 22px; color: #fff; margin-top: 50px; font-weight: bold; text-shadow: 0 0 10px #ff00de; pointer-events: none; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="top-hud" class="hud-text">
            <div>DIST: <span id="ui-score">0</span>km</div>
            <div>TEMPO: <span id="timer">30</span></div>
        </div>
        <div id="center-hud">LVL: <span id="ui-level">1</span></div>

        <div id="message-area">
            <div id="msg-checkpoint" class="msg">CHECKPOINT!</div>
            <div id="msg-level" class="msg">+DIFICULDADE</div>
        </div>

        <canvas id="canvas"></canvas>

        <div id="controls">
            <div class="d-pad"><button id="btn-left">←</button><button id="btn-right">→</button></div>
            <div class="action-btn"><button id="btn-accel" class="btn-rect">ACELERAR</button></div>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen" onclick="initGame(true)">
        <h1 style="color:#ffcc00; font-size: 48px; margin-bottom: 10px; text-shadow: 4px 4px #d32f2f;">NEO ENDURO</h1>
        <p style="color: #00ffff; letter-spacing: 2px;">AUDIO & VISUAL REMASTER</p>
        <p style="font-size: 12px; color: #888; margin-top: 10px;">Ative o som do seu dispositivo</p>
        <div class="blink-text">TOQUE PARA INICIAR</div>
    </div>

    <div id="gameover-screen" class="overlay-screen hidden" onclick="initGame(false)">
        <h1 style="color: #ff0000; font-size: 48px;">FIM DE JOGO</h1>
        <div style="border: 2px solid #fff; padding: 20px; margin: 20px; border-radius: 10px; background: rgba(255,255,255,0.1);">
            <p style="font-size: 20px; margin: 5px;">Distância: <span id="final-score" style="color: #ffcc00;">0</span>km</p>
            <p style="font-size: 20px; margin: 5px;">Nível: <span id="final-level" style="color: #00ff00;">1</span></p>
        </div>
        <div class="blink-text">TOQUE PARA TENTAR NOVAMENTE</div>
    </div>

<script>
    // ==========================================
    // SISTEMA DE ÁUDIO (Web Audio API)
    // ==========================================
    const AudioSys = {
        ctx: null,
        engineOsc: null,
        engineGain: null,
        musicTimer: null,
        noteIndex: 0,

        init: function() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.createEngine();
                this.startMusic();
            } else if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },

        createEngine: function() {
            // Oscilador para o motor (Onda Dente de Serra para som "rasgado")
            this.engineOsc = this.ctx.createOscillator();
            this.engineOsc.type = 'sawtooth';
            this.engineGain = this.ctx.createGain();
            this.engineGain.gain.value = 0; // Começa mudo

            // Filtro para abafar o som e não ficar irritante
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            this.engineOsc.connect(filter);
            filter.connect(this.engineGain);
            this.engineGain.connect(this.ctx.destination);
            this.engineOsc.start();
        },

        updateEngine: function(speedPercent) {
            if (!this.engineOsc) return;
            // Pitch sobe com a velocidade (60Hz a 200Hz)
            this.engineOsc.frequency.linearRampToValueAtTime(60 + (speedPercent * 140), this.ctx.currentTime + 0.1);
            // Volume sobe se estiver acelerando
            let vol = speedPercent > 0.05 ? 0.15 : 0;
            this.engineGain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.1);
        },

        playTone: function(freq, type, duration, vol) {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },

        playNoise: function(duration) { // Para batidas
            if(!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },

        startMusic: function() {
            // Linha de baixo simples (Synthwave Style)
            const bassLine = [65.41, 65.41, 73.42, 65.41, 58.27, 58.27, 48.99, 58.27]; // C2, D2, Bb1, A1 sequence

            if (this.musicTimer) clearInterval(this.musicTimer);

            this.musicTimer = setInterval(() => {
                if(!isRunning) return;
                const freq = bassLine[this.noteIndex % bassLine.length];
                this.playTone(freq, 'square', 0.15, 0.08); // Baixo volume
                this.noteIndex++;
            }, 250); // 120 BPM aprox
        },

        crash: function() { this.playNoise(0.5); },
        beep: function() { this.playTone(880, 'sine', 0.1, 0.1); },
        checkpoint: function() { this.playTone(1200, 'sine', 0.6, 0.2); this.playTone(1800, 'sine', 0.6, 0.2); }
    };

    // ==========================================
    // LÓGICA DO JOGO
    // ==========================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    const roadWidth = 2000;
    const segmentLength = 200;
    const cameraDepth = 0.84;

    let level = 1;
    let baseCheckpointDist = 300000;
    let currentCheckpointDist = baseCheckpointDist;
    let currentMaxSpeed = 12000;

    let segments = [], cars = [], stars = [];
    let playerX = 0, position = 0, speed = 0, distanceTraveled = 0;
    let isRunning = false, timeLeft = 0, totalTime = 0;
    let nextCheckpoint = baseCheckpointDist;
    let savedState = null;
    let currentBiome = 'NORMAL';
    let skyOffset = 0;
    let currentSkyColor = [135, 206, 235];
    let keyLeft = false, keyRight = false, keyFaster = false;

    // Resizer
    function resize() {
        let controlsHeight = document.getElementById('controls').offsetHeight;
        canvas.width = document.getElementById('game-container').clientWidth;
        canvas.height = document.getElementById('game-container').clientHeight - controlsHeight;
        width = canvas.width; height = canvas.height;
    }
    window.addEventListener('resize', resize);
    setTimeout(resize, 100);

    // Helpers
    function lerp(s,e,t){return s*(1-t)+e*t}
    function lerpColor(c1,c2,t){return [Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))]}
    function rgb(c){return `rgb(${c[0]},${c[1]},${c[2]})`}

    function updateEnvironment(dt) {
        let cycleTime = totalTime % 120;
        let cDay=[135,206,235], cOrange=[200,80,20], cPurple=[60,20,80], cBlack=[5,5,15], cNavy=[0,0,80];

        if (cycleTime < 30) currentSkyColor = cDay;
        else if (cycleTime < 60) {
            let t = (cycleTime - 30) / 30;
            if (t < 0.33) currentSkyColor = lerpColor(cDay, cOrange, t*3);
            else if (t < 0.66) currentSkyColor = lerpColor(cOrange, cPurple, (t-0.33)*3);
            else currentSkyColor = lerpColor(cPurple, cBlack, (t-0.66)*3);
        } else if (cycleTime < 90) currentSkyColor = cBlack;
        else {
            let t = (cycleTime - 90) / 30;
            currentSkyColor = lerpColor(cNavy, cDay, t);
        }

        let biomeTime = totalTime % 960;
        let prevBiome = currentBiome;
        if (biomeTime < 240) currentBiome = 'NORMAL';
        else if (biomeTime < 480) currentBiome = 'SNOW';
        else if (biomeTime < 720) currentBiome = 'NORMAL';
        else currentBiome = 'DESERT';
    }

    function addTraffic(count) {
        const totalSegments = segments.length;
        for(let i=0; i<count; i++) {
            let baseEnemySpeed = 3000 + (level * 300);
            cars.push({
                offset: (Math.random() * 1.6) - 0.8,
                z: (position + 3000 + Math.random() * (totalSegments * segmentLength)) % (totalSegments * segmentLength),
                speed: baseEnemySpeed + Math.random() * 4000,
                type: Math.floor(Math.random() * 4)
            });
        }
    }

    function createRoad() {
        segments = [];
        const totalSegments = 4000;
        let index = 0;

        function addRoadSection(length, curve) {
            for (let i = 0; i < length; i++) {
                segments.push({
                    index: index,
                    p1: { world: { z: index * segmentLength }, camera: {}, screen: {} },
                    p2: { world: { z: (index + 1) * segmentLength }, camera: {}, screen: {} },
                    curve: curve,
                    color: Math.floor(index / 3) % 2 ? { r: 100, g: 100, b: 100 } : { r: 90, g: 90, b: 90 }
                });
                index++;
            }
        }

        while(index < totalSegments) {
            addRoadSection(Math.floor(Math.random() * 50 + 50), 0);
            let curveDir = Math.random() > 0.5 ? 1 : -1;
            let curveStrength = Math.random() * 4 + 2;
            let curveLength = Math.floor(Math.random() * 200 + 100);

            if (index >= totalSegments) break;
            addRoadSection(40, curveStrength / 2 * curveDir);
            addRoadSection(curveLength, curveStrength * curveDir);
            addRoadSection(40, curveStrength / 2 * curveDir);
        }

        stars = [];
        for(let i=0; i<80; i++) stars.push({ x: Math.random(), y: Math.random() * 0.4, size: Math.random()*2 + 1 });

        cars = [];
        addTraffic(60);
    }

    function saveGame() {
        savedState = { totalTime, distanceTraveled, nextCheckpoint, level, currentMaxSpeed, currentCheckpointDist, carCount: cars.length };
    }

    function initGame(reset) {
        // Inicializa Audio no primeiro clique (Política dos navegadores)
        AudioSys.init();

        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');

        if (reset || !savedState) {
            createRoad();
            level = 1; currentMaxSpeed = 12000; currentCheckpointDist = baseCheckpointDist; nextCheckpoint = currentCheckpointDist;
            playerX = 0; speed = 0; position = 0; totalTime = 0; distanceTraveled = 0;
            timeLeft = 35; skyOffset = 0;
        } else {
            createRoad();
            cars = [];
            addTraffic(savedState.carCount);
            level = savedState.level; currentMaxSpeed = savedState.currentMaxSpeed; currentCheckpointDist = savedState.currentCheckpointDist; nextCheckpoint = savedState.nextCheckpoint;
            playerX = 0; speed = 0; position = 0; totalTime = savedState.totalTime; distanceTraveled = savedState.distanceTraveled; timeLeft = 30;
        }

        resize();
        updateUI();
        isRunning = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
    }

    function updateUI() {
        document.getElementById('ui-level').innerText = level;
    }

    // ================= RENDER =================
    function project(p, camX, camY, camZ, camDepth, w, h, roadW) {
        p.camera.x = (p.world.x || 0) - camX;
        p.camera.y = (p.world.y || 0) - camY;
        p.camera.z = p.world.z - camZ;
        p.screen.scale = camDepth / p.camera.z;
        p.screen.x = Math.round((w / 2) + (p.screen.scale * p.camera.x * w / 2));
        p.screen.y = Math.round((h / 2) - (p.screen.scale * p.camera.y * h / 2));
        p.screen.w = Math.round((p.screen.scale * roadW * w / 2));
    }

    function drawPoly(ctx, x1, y1, w1, x2, y2, w2, color) {
        ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x1-w1, y1); ctx.lineTo(x2-w2, y2); ctx.lineTo(x2+w2, y2); ctx.lineTo(x1+w1, y1); ctx.closePath(); ctx.fill();
    }

    // NOVO DESENHO DE CARRO: PERSPECTIVA E DETALHES
    function drawTrapezoid(ctx, x, y, wTop, wBottom, h, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x - wTop/2, y - h);
        ctx.lineTo(x + wTop/2, y - h);
        ctx.lineTo(x + wBottom/2, y);
        ctx.lineTo(x - wBottom/2, y);
        ctx.fill();
    }

    function drawCar(ctx, x, y, w, h, isPlayer, type) {
        // Cores (Metalizadas)
        let colorMain, colorDark;
        if(isPlayer) { colorMain = '#d32f2f'; colorDark = '#8e0000'; } // Ferrari Red
        else if(type===0) { colorMain = '#3366ff'; colorDark = '#003399'; } // Blue
        else if(type===1) { colorMain = '#33cc33'; colorDark = '#006600'; } // Green
        else { colorMain = '#ff9900'; colorDark = '#995c00'; } // Orange

        // Sombra
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(x - w * 0.45, y - h * 0.1, w * 0.9, h * 0.1);

        // Pneus (Largos)
        ctx.fillStyle = '#111';
        let tireW = w * 0.22;
        let tireH = h * 0.4;
        ctx.fillRect(x - w * 0.5, y - h * 0.4, tireW, tireH); // Esq
        ctx.fillRect(x + w * 0.5 - tireW, y - h * 0.4, tireW, tireH); // Dir

        // Corpo (Trapézio para perspectiva)
        let bodyWBottom = w;
        let bodyWTop = w * 0.85;
        let bodyH = h * 0.5;
        drawTrapezoid(ctx, x, y - h*0.4, bodyWTop, bodyWBottom, bodyH, colorMain);

        // Cabine (Vidro traseiro)
        let cabinWBottom = w * 0.7;
        let cabinWTop = w * 0.55;
        let cabinH = h * 0.35;
        drawTrapezoid(ctx, x, y - h * 0.9, cabinWTop, cabinWBottom, cabinH, colorDark);

        // Vidro (Degradê retro)
        let glassGradient = ctx.createLinearGradient(0, y-h*1.2, 0, y-h*0.9);
        glassGradient.addColorStop(0, '#87CEFA');
        glassGradient.addColorStop(0.5, '#4682B4');
        glassGradient.addColorStop(1, '#191970');
        if(currentBiome === 'SNOW') glassGradient = '#e0ffff';

        drawTrapezoid(ctx, x, y - h * 0.92, cabinWTop*0.9, cabinWBottom*0.9, cabinH*0.8, glassGradient);

        // Luzes Traseiras (Brilhantes)
        if (!isPlayer) {
            ctx.fillStyle = '#ff0000';
            let lightW = w * 0.15;
            ctx.fillRect(x - w * 0.35, y - h * 0.55, lightW, h * 0.15);
            ctx.fillRect(x + w * 0.35 - lightW, y - h * 0.55, lightW, h * 0.15);
        } else {
            // Detalhe da Ferrari (Grade preta traseira)
            ctx.fillStyle = '#222';
            ctx.fillRect(x - w * 0.25, y - h * 0.6, w * 0.5, h * 0.1);
            // Luzes de freio
            ctx.fillStyle = speed > 0 && !keyFaster ? '#ff3333' : '#990000'; // Acende quando solta acelerador
            ctx.fillRect(x - w * 0.4, y - h * 0.65, w * 0.15, h * 0.1);
            ctx.fillRect(x + w * 0.4 - w * 0.15, y - h * 0.65, w * 0.15, h * 0.1);
        }
    }

    function getBiomeColors(biome, lightLevel) {
        let grass, road, mountain;
        if (biome === 'SNOW') { grass = [240, 240, 255]; road = [150, 150, 160]; mountain = [200, 200, 220]; }
        else if (biome === 'DESERT') { grass = [210, 180, 100]; road = [120, 100, 80]; mountain = [160, 100, 60]; }
        else { grass = [16, 85, 16]; road = [100, 100, 100]; mountain = [34, 139, 34]; }
        let factor = Math.max(0.15, lightLevel);
        return { grass: `rgb(${grass[0]*factor}, ${grass[1]*factor}, ${grass[2]*factor})`, roadBase: road, mountain: `rgb(${mountain[0]*factor}, ${mountain[1]*factor}, ${mountain[2]*factor})`, rumbleLight: biome==='SNOW' ? '#aaa' : '#fff', rumbleDark: biome==='SNOW' ? '#f00' : '#c00' };
    }

    function render() {
        let lightLevel = (currentSkyColor[0] + currentSkyColor[1] + currentSkyColor[2]) / 765;
        let palette = getBiomeColors(currentBiome, lightLevel);

        ctx.fillStyle = rgb(currentSkyColor); ctx.fillRect(0, 0, width, height);

        if (lightLevel < 0.4) {
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                let sx = (s.x + skyOffset) * width;
                if (sx > width) sx -= width; if (sx < 0) sx += width;
                ctx.fillRect(sx, s.y * height, s.size, s.size);
            });
        }

        ctx.fillStyle = palette.mountain;
        for(let i = -1; i <= 1; i++) {
            let startX = (i + skyOffset) * width;
            if (startX > width || startX + width < 0) continue;
            ctx.beginPath(); let baseY = (height/2) + 10;
            ctx.moveTo(startX, baseY); ctx.lineTo(startX + width * 0.15, baseY - height * 0.20); ctx.lineTo(startX + width * 0.30, baseY - height * 0.05); ctx.lineTo(startX + width * 0.55, baseY - height * 0.30); ctx.lineTo(startX + width * 0.75, baseY - height * 0.10); ctx.lineTo(startX + width * 0.90, baseY - height * 0.15); ctx.lineTo(startX + width, baseY); ctx.fill();
        }

        ctx.fillStyle = palette.grass;
        ctx.fillRect(0, height / 2, width, height / 2);

        let startPos = Math.floor(position / segmentLength);
        let maxy = height;
        let cpZ = nextCheckpoint - position;
        if (cpZ < 0) cpZ += segments.length * segmentLength;

        for (let n = startPos; n < startPos + 300; n++) {
            let l = segments[n % segments.length];
            project(l.p1, (playerX * roadWidth) - l.curve, 1000, position - (l.index < startPos ? segments.length * segmentLength : 0), cameraDepth, width, height, roadWidth);
            project(l.p2, (playerX * roadWidth) - l.curve, 1000, position - (l.index < startPos ? segments.length * segmentLength : 0), cameraDepth, width, height, roadWidth);

            if (l.p1.camera.z <= cameraDepth || l.p2.screen.y >= maxy || l.p2.screen.y >= l.p1.screen.y) continue;

            drawPoly(ctx, 0, l.p2.screen.y, width, 0, l.p1.screen.y, width, palette.grass);
            let rumble = l.index % 6 < 3 ? palette.rumbleLight : palette.rumbleDark;
            let rC = palette.roadBase;
            let shade = (Math.floor(l.index/3)%2) ? 1 : 0.9;
            let roadColor = `rgb(${rC[0]*shade*lightLevel}, ${rC[1]*shade*lightLevel}, ${rC[2]*shade*lightLevel})`;

            drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w * 1.2, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w * 1.2, rumble);
            drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w, roadColor);

            if (Math.abs(l.p1.camera.z - cpZ) < segmentLength) {
                let checkColor = (Math.floor(Date.now()/100)%2) ? '#fff' : '#000';
                drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w, checkColor);
                let scale = l.p1.screen.scale;
                let px = l.p1.screen.x + (scale * 2500 * width/2);
                let py = l.p1.screen.y - (scale * 3000 * height/2);
                ctx.fillStyle = '#0f0'; ctx.fillRect(px, py, 20 * scale * width, 100 * scale * height); ctx.fillRect(px - 60*scale*width, py, 80*scale*width, 40*scale*height);
            }
            maxy = l.p2.screen.y;
        }

        let renderList = [];
        cars.forEach(car => {
            let cz = car.z - position;
            if (cz < 0) cz += segments.length * segmentLength;
            if (cz > cameraDepth && cz < 300 * segmentLength) {
                let scale = cameraDepth / cz;
                let sx = Math.round((width / 2) + (scale * ((car.offset * roadWidth) - (playerX * roadWidth)) * width / 2));
                let sy = Math.round((height / 2) + (scale * 1000 * height / 2));
                let sw = scale * roadWidth * width / 2 * 0.25;
                renderList.push({ z: cz, sx: sx, sy: sy, sw: sw, type: car.type });
            }
        });
        renderList.sort((a, b) => b.z - a.z);
        renderList.forEach(item => { if(item.sy > height/2) drawCar(ctx, item.sx, item.sy, item.sw, item.sw * 0.6, false, item.type); });

        drawCar(ctx, width/2, height-20, width*0.25, width*0.15, true, 0);
    }

    // ================= LOOP =================
    let lastTime = 0;
    let lastBeep = 0;

    function loop(time) {
        let dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;

        if (isRunning) {
            totalTime += dt; timeLeft -= dt; updateEnvironment(dt);
            AudioSys.updateEngine(speed / currentMaxSpeed);

            // Som de Beep < 5s (1 por segundo)
            if (timeLeft < 5 && timeLeft > 0) {
                if (Math.floor(timeLeft) < lastBeep) {
                    AudioSys.beep();
                    lastBeep = Math.floor(timeLeft);
                }
            } else { lastBeep = 100; }

            if (timeLeft <= 0) {
                isRunning = false;
                if(AudioSys.engineGain) AudioSys.engineGain.gain.value = 0; // Para motor
                document.getElementById('final-score').innerText = Math.floor(distanceTraveled / 1000);
                document.getElementById('final-level').innerText = level;
                document.getElementById('gameover-screen').classList.remove('hidden');
            }

            position += speed * dt; distanceTraveled += speed * dt;
            while(position >= segments.length*segmentLength) position -= segments.length*segmentLength;
            while(position < 0) position += segments.length*segmentLength;

            if (distanceTraveled >= nextCheckpoint) {
                level++;
                currentMaxSpeed += 500;
                addTraffic(20);
                let addedDist = baseCheckpointDist * (1 + (level * 0.15));
                currentCheckpointDist = addedDist;
                nextCheckpoint += currentCheckpointDist;
                let idealTime = addedDist / currentMaxSpeed;
                let safetyMargin = Math.max(0, 3 - (level * 0.6));
                timeLeft += (idealTime + safetyMargin);

                AudioSys.checkpoint();
                saveGame(); updateUI();
                let msg = document.getElementById('msg-checkpoint'); msg.style.display = 'block'; setTimeout(()=>msg.style.display='none', 2000);
                let msgLvl = document.getElementById('msg-level'); msgLvl.style.display = 'block'; setTimeout(()=>msgLvl.style.display='none', 2000);
            }

            let curve = segments[Math.floor(position/segmentLength)%segments.length].curve;
            if (speed > 0) skyOffset -= curve * dt * (speed / currentMaxSpeed) * 0.05;
            if (skyOffset > 1) skyOffset -= 1; if (skyOffset < 0) skyOffset += 1;

            let dx = dt * 2 * (speed / currentMaxSpeed);
            if (keyLeft) playerX -= dx; if (keyRight) playerX += dx;

            speed += keyFaster ? 100 : -50;
            if ((playerX < -1 || playerX > 1) && speed > 2000) speed -= 200;
            playerX = Math.max(-2, Math.min(2, playerX));
            speed = Math.max(0, Math.min(currentMaxSpeed, speed));

            cars.forEach(c => {
                c.z += c.speed * dt;
                if(c.z >= segments.length*segmentLength) c.z -= segments.length*segmentLength;
                let cz = c.z - position;
                if(cz < 0) cz += segments.length*segmentLength;
                if(cz < 300 && Math.abs(c.offset - playerX) < 0.20) {
                    if (speed > 2000) AudioSys.crash(); // Som de batida
                    speed = 100;
                }
            });

            document.getElementById('ui-score').innerText = Math.floor(distanceTraveled/1000);
            let tEl = document.getElementById('timer'); tEl.innerText = Math.ceil(timeLeft); tEl.style.color = timeLeft < 10 ? '#f00' : '#fc0';
        }
        render();
        requestAnimationFrame(loop);
    }

    const addTouch = (id, down, up) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e)=>{e.preventDefault(); down()}, {passive:false});
        el.addEventListener('touchend', (e)=>{e.preventDefault(); up()});
        el.addEventListener('mousedown', down); el.addEventListener('mouseup', up);
    };
    addTouch('btn-left', ()=>keyLeft=true, ()=>keyLeft=false);
    addTouch('btn-right', ()=>keyRight=true, ()=>keyRight=false);
    addTouch('btn-accel', ()=>keyFaster=true, ()=>keyFaster=false);

</script>
</body>
</html>
