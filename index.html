<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neo Enduro: Wide Screen</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; touch-action: none; }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        canvas {
            display: block;
            width: 100%;
            flex: 1; /* Ocupa todo o espaço sobrando */
            background: #000;
            image-rendering: pixelated;
        }

        /* UI */
        .hud-text { position: absolute; color: #fff; font-weight: bold; text-shadow: 2px 2px #000; z-index: 10; pointer-events: none; }
        #top-hud { top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; font-size: 18px; }
        #timer { color: #ffcc00; font-size: 24px; }

        #center-hud { position: absolute; top: 10%; width: 100%; text-align: center; color: #fff; font-size: 14px; text-shadow: 1px 1px #000; z-index: 9;}

        #message-area { position: absolute; top: 30%; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
        .msg { font-size: 32px; font-weight: 900; text-shadow: 3px 3px #000; display: none; text-transform: uppercase; }
        #msg-checkpoint { color: #00ff00; }
        #msg-biome { color: #00ffff; font-size: 24px; margin-top: 10px; }
        #msg-level { color: #ff00ff; font-size: 20px; margin-top: 5px; }

        /* Controls - Compactos */
        #controls {
            height: 15vh; /* Altura reduzida (15% da tela) */
            min-height: 100px; /* Garante tamanho mínimo */
            background: #222;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 5px 10px;
            border-top: 2px solid #555;
            flex-shrink: 0; /* Impede que encolha demais */
        }

        .d-pad, .action-btn { display: flex; justify-content: center; align-items: center; gap: 15px; }

        button {
            background: linear-gradient(to bottom, #444, #111);
            border: 2px solid #999;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            width: 65px; /* Botões menores */
            height: 65px;
            box-shadow: 0 4px 0 #000;
        }

        button:active { transform: translateY(4px); box-shadow: none; background: #555; }

        .btn-rect {
            border-radius: 10px;
            width: 100%;
            height: 65px; /* Altura ajustada */
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(to bottom, #d32f2f, #8e0000);
            border-color: #ff6659;
        }

        /* Screens */
        .overlay-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 100; text-align: center; }
        .hidden { display: none !important; }
        .start-btn { margin-top: 30px; padding: 15px 40px; font-size: 20px; background: #fff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="top-hud" class="hud-text">
            <div>DIST: <span id="ui-score">0</span>km</div>
            <div>TEMPO: <span id="timer">30</span></div>
        </div>
        <div id="center-hud">NÍVEL: <span id="ui-level">1</span> | MAX SPEED: <span id="ui-maxspeed">120</span>%</div>

        <div id="message-area">
            <div id="msg-checkpoint" class="msg">CHECKPOINT!</div>
            <div id="msg-level" class="msg">+DIFICULDADE</div>
            <div id="msg-biome" class="msg">MUDANÇA DE CLIMA</div>
        </div>

        <canvas id="canvas"></canvas>

        <div id="controls">
            <div class="d-pad"><button id="btn-left">←</button><button id="btn-right">→</button></div>
            <div class="action-btn"><button id="btn-accel" class="btn-rect">ACELERAR</button></div>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen">
        <h1 style="color:#ffcc00">NEO ENDURO</h1>
        <p>Pro Challenge Edition</p>
        <p style="font-size: 12px; color: #aaa;">Chegue aos checkpoints para ganhar tempo.</p>
        <button class="start-btn" onclick="startGame(true)">INICIAR CORRIDA</button>
    </div>

    <div id="gameover-screen" class="overlay-screen hidden">
        <h1>FIM DE JOGO</h1>
        <p>Distância Total: <span id="final-score">0</span>km</p>
        <p>Nível Alcançado: <span id="final-level">1</span></p>
        <button class="start-btn" onclick="startGame(false)">TENTAR NOVAMENTE</button>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // --- Configurações Iniciais ---
    let width, height;
    const roadWidth = 2000;
    const segmentLength = 200;
    const cameraDepth = 0.84;

    // --- Dificuldade ---
    let level = 1;
    let baseCheckpointDist = 300000;
    let currentCheckpointDist = baseCheckpointDist;
    let currentMaxSpeed = 12000;

    // --- Estado do Jogo ---
    let segments = [], cars = [], stars = [];
    let playerX = 0, position = 0, speed = 0, distanceTraveled = 0;
    let isRunning = false, timeLeft = 0, totalTime = 0;
    let nextCheckpoint = baseCheckpointDist;
    let savedState = null;

    // --- Biomas e Ambiente ---
    let currentBiome = 'NORMAL';
    let skyOffset = 0;
    let currentSkyColor = [135, 206, 235];

    // Input
    let keyLeft = false, keyRight = false, keyFaster = false;

    function resize() {
        // Redimensiona baseado no tamanho do pai (que agora é flex: 1)
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight - document.getElementById('controls').offsetHeight;
        // Ajuste fino: pegamos o container menos os controles
        canvas.height = document.getElementById('game-container').clientHeight - document.getElementById('controls').clientHeight;

        width = canvas.width; height = canvas.height;
    }
    window.addEventListener('resize', resize);

    // Chamamos resize no início para ajustar
    setTimeout(resize, 100);

    // ================= HELPERS =================
    function lerp(start, end, t) { return start * (1 - t) + end * t; }
    function lerpColor(c1, c2, t) {
        return [ Math.round(lerp(c1[0],c2[0],t)), Math.round(lerp(c1[1],c2[1],t)), Math.round(lerp(c1[2],c2[2],t)) ];
    }
    function rgb(c) { return `rgb(${c[0]},${c[1]},${c[2]})`; }

    // ================= LÓGICA DE AMBIENTE =================
    function updateEnvironment(dt) {
        let cycleTime = totalTime % 120;
        let cDay = [135, 206, 235]; let cOrange = [200, 80, 20]; let cPurple = [60, 20, 80]; let cBlack = [5, 5, 15]; let cNavy = [0, 0, 80];

        if (cycleTime < 30) currentSkyColor = cDay;
        else if (cycleTime < 60) {
            let t = (cycleTime - 30) / 30;
            if (t < 0.33) currentSkyColor = lerpColor(cDay, cOrange, t*3);
            else if (t < 0.66) currentSkyColor = lerpColor(cOrange, cPurple, (t-0.33)*3);
            else currentSkyColor = lerpColor(cPurple, cBlack, (t-0.66)*3);
        } else if (cycleTime < 90) currentSkyColor = cBlack;
        else {
            let t = (cycleTime - 90) / 30;
            currentSkyColor = lerpColor(cNavy, cDay, t);
        }

        let biomeTime = totalTime % 960;
        let prevBiome = currentBiome;
        if (biomeTime < 240) currentBiome = 'NORMAL';
        else if (biomeTime < 480) currentBiome = 'SNOW';
        else if (biomeTime < 720) currentBiome = 'NORMAL';
        else currentBiome = 'DESERT';

        if(prevBiome !== currentBiome) {
            let el = document.getElementById('msg-biome');
            el.innerText = currentBiome === 'SNOW' ? "ENTRANDO NA NEVE" : (currentBiome === 'DESERT' ? "ENTRANDO NO DESERTO" : "VOLTANDO À FLORESTA");
            el.style.display = 'block'; setTimeout(() => el.style.display = 'none', 3000);
        }
    }

    // ================= GERAÇÃO DE PISTA =================
    function createRoad() {
        segments = [];
        const totalSegments = 4000;
        let index = 0;

        function addRoadSection(length, curve) {
            for (let i = 0; i < length; i++) {
                segments.push({
                    index: index,
                    p1: { world: { z: index * segmentLength }, camera: {}, screen: {} },
                    p2: { world: { z: (index + 1) * segmentLength }, camera: {}, screen: {} },
                    curve: curve,
                    color: Math.floor(index / 3) % 2 ? { r: 100, g: 100, b: 100 } : { r: 90, g: 90, b: 90 }
                });
                index++;
            }
        }

        while(index < totalSegments) {
            addRoadSection(Math.floor(Math.random() * 50 + 50), 0); // Reta
            let curveDir = Math.random() > 0.5 ? 1 : -1;
            let curveStrength = Math.random() * 4 + 2;
            let curveLength = Math.floor(Math.random() * 200 + 100);

            if (index >= totalSegments) break;
            addRoadSection(40, curveStrength / 2 * curveDir); // Ease In
            addRoadSection(curveLength, curveStrength * curveDir); // Hold
            addRoadSection(40, curveStrength / 2 * curveDir); // Ease Out
        }

        stars = [];
        for(let i=0; i<80; i++) stars.push({ x: Math.random(), y: Math.random() * 0.4, size: Math.random()*2 + 1 });

        cars = [];
        for(let i=0; i<60; i++) {
            cars.push({
                offset: (Math.random() * 1.6) - 0.8,
                z: Math.random() * totalSegments * segmentLength,
                speed: 3000 + Math.random() * 7000,
                type: Math.floor(Math.random() * 4)
            });
        }
    }

    function saveGame() {
        savedState = { totalTime, distanceTraveled, nextCheckpoint, level, currentMaxSpeed, currentCheckpointDist };
    }

    function startGame(reset) {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('gameover-screen').classList.add('hidden');
        createRoad();
        resize(); // Garante tamanho correto ao iniciar

        if (reset || !savedState) {
            level = 1; currentMaxSpeed = 12000; currentCheckpointDist = baseCheckpointDist; nextCheckpoint = currentCheckpointDist;
            playerX = 0; speed = 0; position = 0; totalTime = 0; distanceTraveled = 0; timeLeft = 35; skyOffset = 0;
        } else {
            level = savedState.level; currentMaxSpeed = savedState.currentMaxSpeed; currentCheckpointDist = savedState.currentCheckpointDist; nextCheckpoint = savedState.nextCheckpoint;
            playerX = 0; speed = 0; position = 0; totalTime = savedState.totalTime; distanceTraveled = savedState.distanceTraveled; timeLeft = 30;
        }

        updateUI();
        isRunning = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
    }

    function updateUI() {
        document.getElementById('ui-level').innerText = level;
        document.getElementById('ui-maxspeed').innerText = Math.floor(currentMaxSpeed/100);
    }

    // ================= RENDER =================
    function project(p, camX, camY, camZ, camDepth, w, h, roadW) {
        p.camera.x = (p.world.x || 0) - camX;
        p.camera.y = (p.world.y || 0) - camY;
        p.camera.z = p.world.z - camZ;
        p.screen.scale = camDepth / p.camera.z;
        p.screen.x = Math.round((w / 2) + (p.screen.scale * p.camera.x * w / 2));
        p.screen.y = Math.round((h / 2) - (p.screen.scale * p.camera.y * h / 2));
        p.screen.w = Math.round((p.screen.scale * roadW * w / 2));
    }

    function drawPoly(ctx, x1, y1, w1, x2, y2, w2, color) {
        ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(x1-w1, y1); ctx.lineTo(x2-w2, y2); ctx.lineTo(x2+w2, y2); ctx.lineTo(x1+w1, y1); ctx.closePath(); ctx.fill();
    }

    function drawCar(ctx, x, y, w, h, isPlayer, type) {
        let main = isPlayer ? '#d00' : (type==0?'#00d':type==1?'#080':type==2?'#d80':'#555');
        let top = isPlayer ? '#a00' : main;
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(x-w/2+4, y-h*0.1, w, h*0.1);
        ctx.fillStyle = '#111'; let tw = w*0.18; let th = h*0.4; ctx.fillRect(x-w/2, y-h*0.4, tw, th); ctx.fillRect(x+w/2-tw, y-h*0.4, tw, th);
        ctx.fillStyle = main; ctx.fillRect(x-w/2, y-h*0.5, w, h*0.5);
        ctx.fillStyle = top; let cw = w * 0.7; ctx.fillRect(x-cw/2, y-h*0.9, cw, h*0.4);
        ctx.fillStyle = (currentBiome === 'SNOW') ? '#e0ffff' : '#87CEFA'; ctx.fillRect(x-cw/2+2, y-h*0.85, cw-4, h*0.25);
        if(!isPlayer) { ctx.fillStyle = '#ff0'; ctx.fillRect(x-w/2+2, y-h*0.35, w*0.15, h*0.15); ctx.fillRect(x+w/2-w*0.15-2, y-h*0.35, w*0.15, h*0.15); }
    }

    function getBiomeColors(biome, lightLevel) {
        let grass, road, mountain;
        if (biome === 'SNOW') { grass = [240, 240, 255]; road = [150, 150, 160]; mountain = [200, 200, 220]; }
        else if (biome === 'DESERT') { grass = [210, 180, 100]; road = [120, 100, 80]; mountain = [160, 100, 60]; }
        else { grass = [16, 85, 16]; road = [100, 100, 100]; mountain = [34, 139, 34]; }
        let factor = Math.max(0.15, lightLevel);
        return { grass: `rgb(${grass[0]*factor}, ${grass[1]*factor}, ${grass[2]*factor})`, roadBase: road, mountain: `rgb(${mountain[0]*factor}, ${mountain[1]*factor}, ${mountain[2]*factor})`, rumbleLight: biome==='SNOW' ? '#aaa' : '#fff', rumbleDark: biome==='SNOW' ? '#f00' : '#c00' };
    }

    function render() {
        let lightLevel = (currentSkyColor[0] + currentSkyColor[1] + currentSkyColor[2]) / 765;
        let palette = getBiomeColors(currentBiome, lightLevel);

        // 1. CÉU
        ctx.fillStyle = rgb(currentSkyColor);
        ctx.fillRect(0, 0, width, height);

        // 2. ESTRELAS
        if (lightLevel < 0.4) {
            ctx.fillStyle = '#fff';
            stars.forEach(s => {
                let sx = (s.x + skyOffset) * width;
                if (sx > width) sx -= width; if (sx < 0) sx += width;
                ctx.fillRect(sx, s.y * height, s.size, s.size);
            });
        }

        // 3. MONTANHAS
        ctx.fillStyle = palette.mountain;
        for(let i = -1; i <= 1; i++) {
            let startX = (i + skyOffset) * width;
            if (startX > width || startX + width < 0) continue;

            ctx.beginPath();
            // Aqui está a correção: baseY fixo no centro exato + um pequeno ajuste para descer
            let baseY = (height / 2) + 10; // Empurra a base da montanha 10px para baixo da linha do horizonte

            ctx.moveTo(startX, baseY);
            ctx.lineTo(startX + width * 0.15, baseY - height * 0.20);
            ctx.lineTo(startX + width * 0.30, baseY - height * 0.05);
            ctx.lineTo(startX + width * 0.55, baseY - height * 0.30);
            ctx.lineTo(startX + width * 0.75, baseY - height * 0.10);
            ctx.lineTo(startX + width * 0.90, baseY - height * 0.15);
            ctx.lineTo(startX + width, baseY);
            ctx.fill();
        }

        // 4. CORREÇÃO DE HORIZONTE (PREENCHIMENTO DO CHÃO)
        // Isso pinta a metade de baixo da tela com a cor da grama antes de desenhar a estrada.
        // Garante que não haja buracos entre a montanha e a pista.
        ctx.fillStyle = palette.grass;
        ctx.fillRect(0, height / 2, width, height / 2);

        // 5. ESTRADA
        let startPos = Math.floor(position / segmentLength);
        let maxy = height;
        let cpZ = nextCheckpoint - position;
        if (cpZ < 0) cpZ += segments.length * segmentLength;

        for (let n = startPos; n < startPos + 300; n++) {
            let l = segments[n % segments.length];
            project(l.p1, (playerX * roadWidth) - l.curve, 1000, position - (l.index < startPos ? segments.length * segmentLength : 0), cameraDepth, width, height, roadWidth);
            project(l.p2, (playerX * roadWidth) - l.curve, 1000, position - (l.index < startPos ? segments.length * segmentLength : 0), cameraDepth, width, height, roadWidth);

            if (l.p1.camera.z <= cameraDepth || l.p2.screen.y >= maxy || l.p2.screen.y >= l.p1.screen.y) continue;

            drawPoly(ctx, 0, l.p2.screen.y, width, 0, l.p1.screen.y, width, palette.grass);
            let rumble = l.index % 6 < 3 ? palette.rumbleLight : palette.rumbleDark;
            let rC = palette.roadBase;
            let shade = (Math.floor(l.index/3)%2) ? 1 : 0.9;
            let roadColor = `rgb(${rC[0]*shade*lightLevel}, ${rC[1]*shade*lightLevel}, ${rC[2]*shade*lightLevel})`;

            drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w * 1.2, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w * 1.2, rumble);
            drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w, roadColor);

            if (Math.abs(l.p1.camera.z - cpZ) < segmentLength) {
                let checkColor = (Math.floor(Date.now()/100)%2) ? '#fff' : '#000';
                drawPoly(ctx, l.p1.screen.x, l.p1.screen.y, l.p1.screen.w, l.p2.screen.x, l.p2.screen.y, l.p2.screen.w, checkColor);
                let scale = l.p1.screen.scale;
                let px = l.p1.screen.x + (scale * 2500 * width/2);
                let py = l.p1.screen.y - (scale * 3000 * height/2);
                ctx.fillStyle = '#0f0'; ctx.fillRect(px, py, 20 * scale * width, 100 * scale * height); ctx.fillRect(px - 60*scale*width, py, 80*scale*width, 40*scale*height);
            }
            maxy = l.p2.screen.y;
        }

        // 6. CARROS
        let renderList = [];
        cars.forEach(car => {
            let cz = car.z - position;
            if (cz < 0) cz += segments.length * segmentLength;
            if (cz > cameraDepth && cz < 300 * segmentLength) {
                let scale = cameraDepth / cz;
                let sx = Math.round((width / 2) + (scale * ((car.offset * roadWidth) - (playerX * roadWidth)) * width / 2));
                let sy = Math.round((height / 2) + (scale * 1000 * height / 2));
                let sw = scale * roadWidth * width / 2 * 0.25;
                renderList.push({ z: cz, sx: sx, sy: sy, sw: sw, type: car.type });
            }
        });
        renderList.sort((a, b) => b.z - a.z);
        renderList.forEach(item => { if(item.sy > height/2) drawCar(ctx, item.sx, item.sy, item.sw, item.sw * 0.6, false, item.type); });

        // Player
        drawCar(ctx, width/2, height-20, width*0.25, width*0.15, true, 0);
    }

    // ================= LOOP =================
    let lastTime = 0;
    function loop(time) {
        let dt = Math.min(1, (time - lastTime) / 1000);
        lastTime = time;

        if (isRunning) {
            totalTime += dt; timeLeft -= dt; updateEnvironment(dt);

            if (timeLeft <= 0) {
                isRunning = false;
                document.getElementById('final-score').innerText = Math.floor(distanceTraveled / 1000);
                document.getElementById('final-level').innerText = level;
                document.getElementById('gameover-screen').classList.remove('hidden');
            }

            position += speed * dt; distanceTraveled += speed * dt;
            while(position >= segments.length*segmentLength) position -= segments.length*segmentLength;
            while(position < 0) position += segments.length*segmentLength;

            if (distanceTraveled >= nextCheckpoint) {
                level++;
                currentMaxSpeed += 500;
                let addedDist = baseCheckpointDist * (1 + (level * 0.1));
                currentCheckpointDist = addedDist;
                nextCheckpoint += currentCheckpointDist;
                let timeToTravel = addedDist / currentMaxSpeed;
                timeLeft += (timeToTravel + 5);
                saveGame(); updateUI();
                let msg = document.getElementById('msg-checkpoint'); msg.style.display = 'block'; setTimeout(()=>msg.style.display='none', 2000);
                let msgLvl = document.getElementById('msg-level'); msgLvl.style.display = 'block'; setTimeout(()=>msgLvl.style.display='none', 2000);
            }

            let curve = segments[Math.floor(position/segmentLength)%segments.length].curve;
            if (speed > 0) skyOffset -= curve * dt * (speed / currentMaxSpeed) * 0.05;
            if (skyOffset > 1) skyOffset -= 1; if (skyOffset < 0) skyOffset += 1;

            let dx = dt * 2 * (speed / currentMaxSpeed);
            if (keyLeft) playerX -= dx; if (keyRight) playerX += dx;

            speed += keyFaster ? 100 : -50;
            if ((playerX < -1 || playerX > 1) && speed > 2000) speed -= 200;
            playerX = Math.max(-2, Math.min(2, playerX));
            speed = Math.max(0, Math.min(currentMaxSpeed, speed));

            cars.forEach(c => {
                c.z += c.speed * dt;
                if(c.z >= segments.length*segmentLength) c.z -= segments.length*segmentLength;
                let cz = c.z - position;
                if(cz < 0) cz += segments.length*segmentLength;
                if(cz < 300 && Math.abs(c.offset - playerX) < 0.20) speed = 100;
            });

            document.getElementById('ui-score').innerText = Math.floor(distanceTraveled/1000);
            let tEl = document.getElementById('timer'); tEl.innerText = Math.ceil(timeLeft); tEl.style.color = timeLeft < 10 ? '#f00' : '#fc0';
        }
        render();
        requestAnimationFrame(loop);
    }

    const addTouch = (id, down, up) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e)=>{e.preventDefault(); down()}, {passive:false});
        el.addEventListener('touchend', (e)=>{e.preventDefault(); up()});
        el.addEventListener('mousedown', down); el.addEventListener('mouseup', up);
    };
    addTouch('btn-left', ()=>keyLeft=true, ()=>keyLeft=false);
    addTouch('btn-right', ()=>keyRight=true, ()=>keyRight=false);
    addTouch('btn-accel', ()=>keyFaster=true, ()=>keyFaster=false);

</script>
</body>
</html>
